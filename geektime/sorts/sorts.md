# 排序

最常用的：  
[冒泡排序](https://github.com/MSunFlower1014/LeetCode-Golang/tree/master/geektime/sorts/bubbleSort.go)  
[插入排序](https://github.com/MSunFlower1014/LeetCode-Golang/tree/master/geektime/sorts/insertionSort.go)  
[选择排序](https://github.com/MSunFlower1014/LeetCode-Golang/tree/master/geektime/sorts/selectionSort.go)  
[归并排序](https://github.com/MSunFlower1014/LeetCode-Golang/tree/master/geektime/sorts/mergeSort.go)  
[快速排序](https://github.com/MSunFlower1014/LeetCode-Golang/tree/master/geektime/sorts/quickSort.go)  
计数排序  
基数排序  
桶排序  

冒泡排序、插入排序、选择排序这三种排序算法，它们的时间复杂度都是 O(n2)，适合小规模数据的排序。
归并排序和快速排序的时间复杂度为 O(nlogn)

冒泡排序和插入排序的时间复杂度都是 O(n2)，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？  
冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个  
冒泡排序实现-三次交换

归并排序的处理过程是由下到上的，先处理子问题，然后再合并。  
而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。  
归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。

## 桶排序
Bucket sort
核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。  
桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。  
桶排序比较适合用在外部排序中。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。  

## 计数排序
Counting sort  
计数排序其实是桶排序的一种特殊情况。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。  
每个桶内的数据值都是相同的，省掉了桶内排序的时间。  
计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。  
而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。

## 基数排序  
Radix sort  
基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，  
如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。  
除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，  
否则，基数排序的时间复杂度就无法做到 O(n) 了。

## 总结
|算法名|时间复杂度|是否稳定|是否原地|
|----|----|----|----|
|冒泡排序|O(n2)|√|√|
|插入排序|O(n2)|√|√|
|选择排序|O(n2)|×|√|
|快速排序|O(nLog n )|×|√|
|归并排序|O(nLog n )|√|×|
|计数排序|O(n+k) k为数据范围|√|×|
|桶排序|O(n)|√|×|
|基数排序|O(d n) d为维度|√|×|

## C语言 q sort 排序实现
qsort() 会优先使用归并排序来排序输入数据，因为归并排序的空间复杂度是 O(n)
排序的数据量比较大的时候，qsort() 会改为用快速排序算法来排序。  
qsort() 选择分区点的方法就是“三数取中法”  
当要排序的区间中，元素的个数小于等于 4 时，qsort() 就退化为插入排序  