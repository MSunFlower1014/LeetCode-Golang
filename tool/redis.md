# REDIS

## 特定
1.类型支持多样化:string,list,set,hash,sorSet  
2.可持久化  
3.数据存储在内存  

## 字符串 Strings
最基本的类型，二进制安全，可以存储图片，最大存储512M字节的内容  
应用：  
* 利用INCR当作原子计数器
* 使用APPEND追加内容（当key不存在时会直接存储为value）
* 通过 GETRANGE 和 SETRANGE 随机访问字符串
* 通过SETBIT和GETBIT创建bloom过滤器(或者统计登陆日期)
* SET NX 和lua脚本完成分布式锁
* SESSION共享

### 常用命令
GET SET  
MGET MSET --- 设置或获取多个key的值  
INCR DECR  ---  原子增加或减少  
GETSET  ---  设置一个新的值，并返回旧值  
GETBIT SETBIT  --- 位操作  
BITCOUNT  ---  统计位设置为1的数量  
SETNX  --- 当key不存在时设置键值对  


## 数组Lists
基于链表实现，头部和尾部插入复杂度为O(1)  
Redis列表是简单的字符串列表，按照插入顺序排序。  
你可以添加一个元素到列表的头部（左边）或者尾部（右边）。  
LPUSH 命令插入一个新元素到列表头部  
LTRIM 修建列表长度，如 LTRIM myList 0 99 ,列表长度不会超过100
应用:  
* 你可以同时使用LPUSH和LTRIM去创建一个永远不会超过指定元素数目的列表并同时记住最后的N个元素。(如最新的消息和评论，最新日志)

### 常用命令
LPOP LPUSH  ---  队列的左边入队或出队   
BLPOP BRPOP  ---  阻塞获取左侧或右侧元素  
LREM LSET  ---  删除或设置值  

## 集合Sets
哈希表实现，添加，删除以及测试复杂度为O(1)  
不允许相同成员存在  
应用：
* srandmember随机展示（分布式全集信息随机展示且唯一）
* 交集查共同好友或者共同喜好

### 常用命令
SADD SPOP SREM  ---  设置，删除并获取，删除元素
SINSERT SDIFF  ---  获取集合的交集，不存在元素  
SSCAN  ---  增量迭代set

## 哈希Hashes
小散列表使用的内存非常小，所以尽可能的将你的数据模型抽象到一个散列表里。  
当数据较少时使用有序数组实现，有利于CPU的缓存命中   
比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面.  
同类型的简单key value可通过哈希存储，string类型需要消耗额外的空间存储元数据和指针  

### 常用命令  
HSET HGET HDEL HMGET  ---  设置,获取或删除哈希的字段值,获取多个字段值

## 有序集合SortedSets
通过压缩列表和调表实现，保证效率为O(log(N))  
应用：
* 排行榜(服务调用排行)
ZADD和ZRANK命令  

### 常用命令
ZADD ZREM  ---  添加或删除元素  
ZINCRBY ---  原子增加元素分数  
ZRANK ---  确定元素在sortSet中的索引，及排行  
ZRANGE ZRANGEBYSCORE ---   根据索引或者分数获取成员列表  
ZREMRANGEBYSCORE ---  根据分数删除成员，返回删除元素个数  
ZCORE --- 获取指定成员的分数  
ZSCAN --- 迭代sorted sets 中元素  

### 高级类型
* GEO 地理位置支持  
将经纬度信息按照分区转换为二进制数字，将经纬度二进制数字组合通过sortSets存储
* HyperLogLog 统计支持（结果有0.81%的偏差）  
* BitMap 只记录二值状态，有效减少内存空间  


## redis快的原因
1.单线程处理，无切换线程损耗   
2.epoll多路复用，避免CPU资源浪费  
3.数据在内存里，读写快  
4.数据结构都有所优化:  
* sortedSets数据量小时为压缩列表，利于存储和CPU预读，数据大时为调表，复杂度为O(log(N))
* 字符串，集合等数据都会单独存储其长度信息  
5.全局数据通过hash表查找，复杂度为O(1)  


## 持久化
RDB-内存快照，将某个时间点的所有数据储存到硬盘，速度慢

AOF-日志记录，通过逐一记录操作命令，在恢复时再逐一执行命令的方式，保证了数据的可靠性。速度快

最佳实践:
数据不能丢失时，内存快照和 AOF 的混合使用是一个很好的选择；  
如果允许分钟级别的数据丢失，可以只使用 RDB；  
如果只用 AOF，优先使用 everysec(每秒同步)的配置选项，因为 everysec 时redis使用后台子进程完成fsync操作，当为 always 时，由主进程同步执行，会造成阻塞。


## 内存优化
1.使用32位的redis，指针占用的字节更小，但实例内存将被限制在4G一下。RDB和AOF文件兼容32位与64位  
2.尽可能使用小散列表存储关联数据，比单独得key节约内存且响应更快  

## key过期
1.被动方式：key被访问时，发现并过期  
2.主动方式：100ms一次过期检测，随机挑选20个key，删除所有过期keys，如果超过25%的keys过期，重复该步骤  

## 分区
如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。  
如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。  

两种实现：  
* 一致性hash  
* 哈希槽  

## 单线程
Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。  
但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。  

## 阻塞操作
1.集合全量查询和聚合操作（改用单独的从库进行，避免阻塞主库）  
2.删除big keys  
3.清空数据库，如flushDB操作  
4.AOF日志同步写（设置为always）  
5.加载RDB文件  

## redis变慢
* 大量key过期
* 是否使用了慢命令，如keys，sort等排序、交集、并集等操作  

## SCAN不会漏key，但可能重复返回
1.为什么不会漏key？  
[高位进位加法](https://blog.csdn.net/u014439693/article/details/108325632)  
2.为什么会重复？  
这个情况主要发生在哈希表缩容。已经遍历过的哈希桶在缩容时，会映射到新哈希表没有遍历到的位置，所以继续遍历就会对同一个key返回多次。  


## 缓存异常
* 缓存击穿  
缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力  
如：大量key过期；redis实例宕机  
解决：过期时间增加随机值；非核心数据直接返回null而不查询数据库导致拖垮数据库  
* 缓存雪崩  
缓存雪崩，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。  
热点数据过期失效  
解决：核心数据不设置过期，主动通过删除更新  
* 缓存穿透  
缓存穿透，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。  
请求不存在的数据  
解决：布隆过滤器；业务直接返回空值不允许透查数据库   

## 秒杀支撑
1.尽量静态化  
2.请求拦截和流控  
3.数据单独处理（比如h5的秒杀库）  

## 数据倾斜
热点数据频繁访问，导致服务压力过大  
解决：热点数据多副本，业务层随机访问  

## LRU实现
内存限制通过redis.config 中的maxmemory 设置最大内存占用量  
淘汰策略设置为LRU时，根据设置，达到最大内存使用量时，取样n个key，删除时间最早的key，重复该过程，直到内存足够使用  
查询命令直接返回，并异步删除数据；更新和插入命令等待删除结束后执行  
当取样数越大时，淘汰越精确，但会消耗更多的CPU资源  
取样数默认为5，为10时效率接近真实算法，可通过config set maxmemory-samples 设置  
[参考文章-深入理解Redis数据缓存的LRU实现机制](https://blog.csdn.net/azurelaker/article/details/85045245)  
[参考文章-将redis当做使用LRU算法的缓存来使用](http://www.redis.cn/topics/lru-cache.html)  