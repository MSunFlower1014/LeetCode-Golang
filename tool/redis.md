# REDIS

## 特定
1.类型支持多样化:string,list,set,hash,sorSet  
2.可持久化  
3.数据存储在内存  

## 字符串 Strings
最基本的类型，二进制安全，可以存储图片，最大存储512M字节的内容  
应用：  
* 利用INCR当作原子计数器
* 使用APPEND追加内容（当key不存在时会直接存储为value）
* 通过 GETRANGE 和 SETRANGE 随机访问字符串
* 通过SETBIT和GETBIT创建bloom过滤器(或者统计登陆日期)
* SET NX 和lua脚本完成分布式锁
* SESSION共享

## 数组Lists
基于链表实现，头部和尾部插入复杂度为O(1)  
Redis列表是简单的字符串列表，按照插入顺序排序。  
你可以添加一个元素到列表的头部（左边）或者尾部（右边）。  
LPUSH 命令插入一个新元素到列表头部  
应用:  
* 你可以同时使用LPUSH和LTRIM去创建一个永远不会超过指定元素数目的列表并同时记住最后的N个元素。(如最新的消息和评论，最新日志)

## 集合Sets
添加，删除以及测试复杂度为O(1)  
不允许相同成员存在  
应用：
* srandmember随机展示（分布式全集信息随机展示且唯一）
* 交集查共同好友或者共同喜好

## 哈希Hashes
小散列表使用的内存非常小，所以尽可能的将你的数据模型抽象到一个散列表里。  
当数据较少时使用有序数组实现，有利于CPU的缓存命中   
比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面.  

## 有序集合SortedSets
通过压缩列表和调表实现，保证效率为O(log(N))  
应用：
* 排行榜(服务调用排行)

### 高级类型
* GEO 地理位置支持  
将经纬度信息按照分区转换为二进制数字，将经纬度二进制数字组合通过sortSets存储
* HyperLogLog 统计支持（结果有0.81%的偏差）  
* BitMap 只记录二值状态，有效减少内存空间  


## redis快的原因
1.单线程处理，无切换线程损耗   
2.多路复用，避免CPU资源浪费  
3.数据在内存里，读写快  
4.数据结构都有所优化:  
* sortedSets数据量小时为压缩列表，利于存储和CPU预读，数据大时为调表，复杂度为O(log(N))
* 字符串，集合等数据都会单独存储其长度信息
* 数据通过hash表查找，复杂度为O(1)


## 持久化
RDB-内存快照，将某个时间点的所有数据储存到硬盘，速度慢

AOF-日志记录，通过逐一记录操作命令，在恢复时再逐一执行命令的方式，保证了数据的可靠性。速度快

最佳实践:
数据不能丢失时，内存快照和 AOF 的混合使用是一个很好的选择；  
如果允许分钟级别的数据丢失，可以只使用 RDB；  
如果只用 AOF，优先使用 everysec(每秒同步)的配置选项，因为 everysec 时redis使用后台子进程完成fsync操作，当为 always 时，由主进程同步执行，会造成阻塞。


## 内存优化
1.使用32位的redis，指针占用的字节更小，但实例内存将被限制在4G一下。RDB和AOF文件兼容32位与64位  
2.尽可能使用小散列表存储关联数据，比单独得key节约内存且响应更快  

## 内存淘汰
1.被动方式：key被访问时，发现并过期  
2.主动方式：100ms一次过期检测，随机挑选20个key，删除所有过期keys，如果超过25%的keys过期，重复该步骤  

## 分区
如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。  
如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。  

两种实现：  
* 一致性hash
* 哈希槽

## 单线程
Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。  
但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。  

## 阻塞操作
1.集合全量查询和聚合操作（改用单独的从库进行，避免阻塞主库）  
2.删除big keys  
3.清空数据库，如flushDB操作  
4.AOF日志同步写  
5.加载RDB文件

## redis变慢
* 大量key过期
* 是否使用了慢命令，如keys，sort等排序、交集、并集等操作  

## SCAN不会漏key，但可能重复返回
1.为什么不会漏key？  
[高位进位加法](https://blog.csdn.net/u014439693/article/details/108325632)  
2.为什么会重复？  
这个情况主要发生在哈希表缩容。已经遍历过的哈希桶在缩容时，会映射到新哈希表没有遍历到的位置，所以继续遍历就会对同一个key返回多次。  


## 缓存异常
* 缓存击穿  
大量key过期；redis实力宕机  
解决：过期时间增加随机值；非核心数据直接返回null而不查询数据库导致拖垮数据库  
* 缓存击穿  
热点数据过期失效  
解决：核心数据不设置过期，主动通过删除更新  
* 缓存穿透  
请求不存在的数据  
解决：布隆过滤器；业务直接返回空值不允许透查数据库   

## 秒杀支撑
1.尽量静态化  
2.请求拦截和流控  
3.数据单独处理（比如h5的秒杀库）  

## 数据倾斜
热点数据多副本，业务层随机访问  