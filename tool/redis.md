# REDIS

## 特定
1.类型支持多样化:string,list,set,hash,sorSet  
2.可持久化  
3.数据存储在内存

## 字符串 Strings
最基本的类型，二进制安全，可以存储图片，最大存储512M字节的内容  
应用：  
* 利用INCR当作原子计数器
* 使用APPEND追加内容（当key不存在时会直接存储为value）
* 通过 GETRANGE 和 SETRANGE 随机访问字符串
* 通过SETBIT和GETBIT创建bloom过滤器(或者统计登陆日期)
* SET NX 和lua脚本完成分布式锁
* SESSION共享

## 数组Lists
基于链表实现，头部和尾部插入复杂度为O(1)  
Redis列表是简单的字符串列表，按照插入顺序排序。  
你可以添加一个元素到列表的头部（左边）或者尾部（右边）。  
LPUSH 命令插入一个新元素到列表头部  
应用:  
* 你可以同时使用LPUSH和LTRIM去创建一个永远不会超过指定元素数目的列表并同时记住最后的N个元素。(如最新的消息和评论，最新日志)

## 集合Sets
添加，删除以及测试复杂度为O(1)  
不允许相同成员存在  
应用：
* srandmember随机展示（分布式全集信息随机展示且唯一）
* 交集查共同好友或者共同喜好

## 哈希Hashes

## 有序集合SortedSets
通过压缩列表和调表实现，保证效率为O(log(N))  
应用：
* 排行榜(服务调用排行)


## redis快的原因
1.单线程处理，无切换线程损耗   
2.多路复用，避免CPU资源浪费  
2.数据在内存里，读写快  
3.数据结构都有所优化:  
* sortedSets数据量小时为压缩列表，利于存储和CPU预读，数据大时为调表，复杂度为O(log(N))
* 字符串，集合等数据都会单独存储其长度信息
* 数据通过hash表查找，复杂度为O(1)


## 持久化
RDB-内存快照，将某个时间点的所有数据储存到硬盘，速度慢

AOF-日志记录，通过逐一记录操作命令，在恢复时再逐一执行命令的方式，保证了数据的可靠性。速度快

最佳实践:
数据不能丢失时，内存快照和 AOF 的混合使用是一个很好的选择；  
如果允许分钟级别的数据丢失，可以只使用 RDB；  
如果只用 AOF，优先使用 everysec(每秒同步)的配置选项，因为它在可靠性和性能之间取了一个平衡。