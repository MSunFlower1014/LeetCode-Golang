# MYSQL

## 建议
1.在联合索引中将选择性最高的列放在索引最前面。  
以age 和gender为索引，显然age要放在前面，因为性别就两种选择男或女，选择性不如age  
2.永远设置主键且最好设置为int且自增，字符串的排序比int复杂很多  
3.多使用explain查看SQL复杂度  
4.尽量设置not null，存在null列会使索引失效
5.拆分大的insert和delete，分批次执行  
6.明确只有一条的时候加 LIMIT 1  
7.like条件 % 不能放在前面，会导致索引树排序失效  
8.尽量不要使用内置函数（根据耗时统计，通过函数计算不会使用索引，直接入库时记录才好）  
9.Inner join 、left join、right join，优先使用Inner join，如果是left join，左边表结果尽量小。  
Inner join 内连接，在两张表进行连接查询时，只保留两张表中完全匹配的结果集；  
left join 在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录；  
right join 在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录。  
10.不要使用!=  
11.count(字段)<count(主键 id)<count(1)≈count(*)，所以我建议你，尽量使用 count(*)


## 慢查询
表设计问题，是否无索引  
SQL问题，是否未用到索引  
索引失效  
join的表太多了  
数据量太大，是否需要分库分表  
数据库服务器IO磁盘或磁盘性能不行  
网络是否波动  
请求量是否过大，是否可以增加缓存  

## SQL执行流程
客户端 -> 连接器（管理连接，权限验证） -> 分析器（语法分析） -> 优化器（执行计划生成，索引选择） - > 执行器（操作引起，返回结果） -> 存储引擎（存储数据，提供读写接口）-> 返回结果  
[参考连接](https://time.geekbang.org/column/article/68319)

### 更新执行流程
客户端 -> 连接器（管理连接，权限验证） -> 分析器（语法分析） -> 优化器（执行计划生成，索引选择） - > 执行器（操作引起，返回结果） -> 存储引擎更新数据（存储数据，提供读写接口）-> 写入redolog，处于prepare阶段 -> 提交事务 -> 写入binlog -> redolog改为commit状态 -> 完成
## 长连接
为减少建立连接的损耗，建议尽量使用长连接  
长连接内存消耗可能过快，是由于执行过程中使用的内存在断开连接时才释放，长期累积，可能导致OOM  
解决：1.定时或执行大查询后断开连接2.执行mysql_reset_connection 来重新初始化连接资源  

## ACID
* 原子性（atomicity)  
一个事务要么全部提交成功，要么全部失败回滚，不能只执行其中的一部分操作，这就是事务的原子性
* 一致性（consistency)  
事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处于一致性状态。  
如果数据库系统在运行过程中发生故障，有些事务尚未完成就被迫中断，这些未完成的事务对数据库所作的修改有一部分已写入物理数据库，这是数据库就处于一种不正确的状态，也就是不一致的状态  
* 隔离性（isolation）  
事务的隔离性是指在并发环境中，并发的事务时相互隔离的，一个事务的执行不能不被其他事务干扰。  
不同的事务并发操作相同的数据时，每个事务都有各自完成的数据空间，即一个事务内部的操作及使用的数据对其他并发事务时隔离的，并发执行的各个事务之间不能相互干扰。  
* 持久性（durability）  
一旦事务提交，那么它对数据库中的对应数据的状态的变更就会永久保存到数据库中。--即使发生系统崩溃或机器宕机等故障，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束的状态
## 隔离级别
并发可能导致：脏读:读到其他事务未提交的数据；不可重复读：前后读取的记录内容不一致；幻读：前后读取的记录数量不一致。  
读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。  
读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。  
可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。  
串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。 

## 可重复读级别下如何防止幻读
产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB 只好引入新的锁，也就是间隙锁 (Gap Lock)。

## 锁
* 全局锁  
 MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。使整个库处于只读状态，用于全库逻辑备份。  
* 表级锁  
表锁的语法是 lock tables … read/write  
另一类表级的锁是 MDL（metadata lock)  
* 行锁
MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。
* 间隙锁
for update 不止会锁住所在行，也会锁住与上下的间隙，间隙锁之间可重复，不会冲突，只是不允许插入新值（多个交集间隙锁可能会导致死锁）    

## 索引
### 主键索引  
也成为聚簇索引，叶子节点存储整行数据
### 普通索引  
叶子节点存储索引值及主键值  
### 唯一索引
与普通索引类似，但索引值唯一，因内存页读取插入与查询无较大差异，普通索引更新可通过change buffer （会定时更新到数据页，称为merge）批量处理提升效率
### 前缀索引
索引值为索引列的前n位，如数据最后几位差异度很小，可通过前缀索引较小索引长度提升效率  
### 联合索引
根据联合列从左到右排序，最左原则，索引覆盖时无需回表提升效率    
叶子节点存储索引列及主键值  

## 长事务风险
* 长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。   
* 长事务还占用锁资源，提交时才会释放所有锁，也可能拖垮整个库  

## 数据库死锁处理
事务在提交时才会释放获取到的锁  
1.通过超时时间来回滚对应事务  
2.开启死锁检测，主动释放其中一个事务的锁  

## binlog和redoLog的持久化
通过设置指定n个事务后持久化,当设置为双一时，每个事务提交之后都会将log持久化。  
sync_binlog=0 的时候，表示每次提交事务都只 write，不 fsync；  
sync_binlog=1 的时候，表示每次提交事务都会执行 fsync；  
sync_binlog=N(N>1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。  
为了控制 redo log 的写入策略，InnoDB 提供了 innodb_flush_log_at_trx_commit 参数，它有三种可能取值：  
设置为 0 的时候，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ;  
设置为 1 的时候，表示每次事务提交时都将 redo log 直接持久化到磁盘；  
设置为 2 的时候，表示每次事务提交时都只是把 redo log 写到 page cache。  
##死锁
* 间隙锁互相保护导致死锁：
session A 执行 select … for update 语句，由于 id=9 这一行并不存在，因此会加上间隙锁 (5,10);  
session B 执行 select … for update 语句，同样会加上间隙锁 (5,10)，间隙锁之间不会冲突，因此这个语句可以执行成功；  
session B 试图插入一行 (9,9,9)，被 session A 的间隙锁挡住了，只好进入等待；  
session A 试图插入一行 (9,9,9)，被 session B 的间隙锁挡住了。

* 行锁等待
session A 执行 select … for update 语句，获取行锁 9;  
session B 执行 select … for update 语句，获取行锁 8;  
session A 更新9后需要更新8，由于8的行锁被B持有，进入等待；  
session A 更新8后需要更新9，由于9的行锁被A持有，进入等待；  

##主从同步
备库 B 跟主库 A 之间维持了一个长连接。  
主库 A 内部有一个线程，专门用于服务备库 B 的这个长连接。  
一个事务日志同步的完整过程是这样的：  
在备库 B 上通过 change master 命令，设置主库 A 的 IP、端口、用户名、密码，以及要从哪个位置开始请求 binlog，这个位置包含文件名和日志偏移量。  
在备库 B 上执行 start slave 命令，这时候备库会启动两个线程，就是图中的 io_thread 和 sql_thread。  
其中 io_thread 负责与主库建立连接。主库 A 校验完用户名、密码后，开始按照备库 B 传过来的位置，从本地读取 binlog，发给 B。  
备库 B 拿到 binlog 后，写到本地文件，称为中转日志（relay log）。sql_thread 读取中转日志，解析出日志里的命令，并执行。  
binlog分为三种格式：
statement：存储原执行sql（可能造成不同步问题，如索引选择不同导致delete limit n删除的数据不同）  
row：存储执行表与修改的具体数据  
mixed：混合式，mysql会自己判断是否需要记录修改的具体数据  


## change buffer
假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在 change buffer，  但之后由于马上要访问这个数据页，会立即触发 merge 过程。  
这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价。所以，对于这种业务模式来说，change buffer 反而起到了副作用。  

## 异常重启回复
如果binlog事务记录完整，redolog状态为commit，直接进行回复  
如果，redolog状态为prepare，则判断binlog的事务是否完整，完整则提交该事务并提交，不完整则回滚事务  
MySQL 怎么知道 binlog 是完整的?  
一个事务的 binlog 是有完整格式的：  
statement 格式的 binlog，最后会有 COMMIT；  
row 格式的 binlog，最后会有一个 XID event。  
  
## 参考文章  
[深入浅出索引-上](https://time.geekbang.org/column/article/69236)
[深入浅出索引-下](https://time.geekbang.org/column/article/69636)